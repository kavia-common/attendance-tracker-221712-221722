from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, Any, List

from flask import g
from flask.views import MethodView
from flask_smorest import Blueprint, abort
from marshmallow import Schema, fields, validate

from app.middleware.auth import firebase_auth_required

# In-memory store placeholder to simulate persistence where a real Firebase DB client would be used.
# This allows endpoints to function and be tested without external setup.
_SESSIONS: Dict[str, Dict[str, Any]] = {}
_ATTENDANCE: List[Dict[str, Any]] = []


def _utcnow() -> datetime:
    return datetime.now(timezone.utc)


class CreateSessionSchema(Schema):
    class Meta:
        ordered = True

    title = fields.String(required=True, description="Session title or topic")
    class_id = fields.String(required=True, description="Class identifier")
    start_time = fields.DateTime(
        required=False,
        description="UTC ISO8601 start timestamp; defaults to now if omitted",
    )
    duration_minutes = fields.Integer(
        required=False, missing=60, validate=validate.Range(min=5, max=480),
        description="Duration in minutes (default 60, min 5, max 480)"
    )
    session_code = fields.String(
        required=False,
        description="Optional teacher-provided session code; autogenerated if missing",
    )


class CreateSessionResponseSchema(Schema):
    class Meta:
        ordered = True

    session_id = fields.String(required=True)
    class_id = fields.String(required=True)
    title = fields.String(required=True)
    start_time = fields.DateTime(required=True)
    end_time = fields.DateTime(required=True)
    created_by = fields.String(required=True)
    session_code = fields.String(required=True)


class MarkAttendanceSchema(Schema):
    class Meta:
        ordered = True

    session_id = fields.String(required=True, description="Target session ID")
    status = fields.String(
        required=False,
        missing="present",
        validate=validate.OneOf(["present", "absent", "late"]),
        description="Attendance status, default present"
    )
    reason = fields.String(
        required=False,
        allow_none=True,
        description="Optional reason, e.g., late justification"
    )
    student_id = fields.String(
        required=False,
        description="Teacher override: mark attendance for a specific student (requires teacher role)"
    )
    override = fields.Boolean(
        required=False,
        missing=False,
        description="When true and caller is a teacher, allows marking for another student or overriding existing"
    )


class AttendanceResponseSchema(Schema):
    class Meta:
        ordered = True

    record_id = fields.String(required=True)
    session_id = fields.String(required=True)
    student_id = fields.String(required=True)
    status = fields.String(required=True)
    reason = fields.String(allow_none=True)
    marked_at = fields.DateTime(required=True)
    marked_by = fields.String(required=True)
    override = fields.Boolean(required=True)


class DailyReportQuerySchema(Schema):
    class Meta:
        ordered = True

    class_id = fields.String(required=True)
    date = fields.Date(
        required=False,
        description="Date in UTC (YYYY-MM-DD). Defaults to today UTC when omitted."
    )


class DailyReportResponseItemSchema(Schema):
    session_id = fields.String(required=True)
    class_id = fields.String(required=True)
    title = fields.String(required=True)
    date = fields.Date(required=True)
    total_marked = fields.Integer(required=True)
    present = fields.Integer(required=True)
    absent = fields.Integer(required=True)
    late = fields.Integer(required=True)


class WeeklyReportQuerySchema(Schema):
    class Meta:
        ordered = True

    class_id = fields.String(required=True)
    week_start = fields.Date(
        required=False,
        description="Start date (Monday) of the week, UTC, YYYY-MM-DD. Defaults to Monday of current week."
    )


class WeeklyReportResponseItemSchema(Schema):
    session_id = fields.String(required=True)
    class_id = fields.String(required=True)
    title = fields.String(required=True)
    date = fields.Date(required=True)
    total_marked = fields.Integer(required=True)
    present = fields.Integer(required=True)
    absent = fields.Integer(required=True)
    late = fields.Integer(required=True)


blp = Blueprint(
    "Attendance",
    "attendance",
    url_prefix="",
    description="Session management, attendance marking, and report endpoints"
)


def _require_teacher():
    if "teacher" not in (g.roles or []):
        abort(403, message="Teacher role required for this action")


def _generate_session_id(class_id: str) -> str:
    return f"sess_{class_id}_{int(_utcnow().timestamp())}"


def _generate_session_code(session_id: str) -> str:
    # Simple, deterministic short code from session id; replace with secure random in prod
    return session_id[-6:].upper()


def _generate_record_id(session_id: str, student_id: str, idx: int) -> str:
    return f"rec_{session_id}_{student_id}_{idx}"


@blp.route("/sessions")
class CreateSession(MethodView):
    """Create an attendance session within a class.

    POST /sessions
    Requires Authorization: Bearer <id_token> and teacher role.

    Business rules:
      - start_time defaults to now (UTC).
      - duration_minutes defaults to 60 and must be between 5 and 480.
      - session_code is auto-generated if not provided.
    """
    decorators = [firebase_auth_required]

    @blp.arguments(CreateSessionSchema, location="json")
    @blp.response(201, CreateSessionResponseSchema)
    @blp.alt_response(403, description="Forbidden when non-teacher attempts to create a session")
    def post(self, json_data):
        _require_teacher()

        title: str = json_data["title"]
        class_id: str = json_data["class_id"]
        duration_minutes: int = json_data.get("duration_minutes", 60)

        start_time_raw: Optional[str] = json_data.get("start_time")
        if start_time_raw:
            try:
                start_time = datetime.fromisoformat(start_time_raw.replace("Z", "+00:00"))
            except Exception:
                abort(400, message="Invalid start_time; must be ISO8601")
        else:
            start_time = _utcnow()

        start_time = start_time.astimezone(timezone.utc)
        end_time = start_time + timedelta(minutes=duration_minutes)

        session_id = _generate_session_id(class_id)
        session_code = json_data.get("session_code") or _generate_session_code(session_id)

        _SESSIONS[session_id] = {
            "session_id": session_id,
            "class_id": class_id,
            "title": title,
            "start_time": start_time,
            "end_time": end_time,
            "created_by": g.user_id,
            "session_code": session_code,
        }

        return {
            "session_id": session_id,
            "class_id": class_id,
            "title": title,
            "start_time": start_time,
            "end_time": end_time,
            "created_by": g.user_id,
            "session_code": session_code,
        }, 201


@blp.route("/attendance/mark")
class MarkAttendance(MethodView):
    """Mark or override attendance for a session.

    POST /attendance/mark
    Requires Authorization: Bearer <id_token>.

    Business rules:
      - Students may mark their own attendance once per session within the session window (start_time <= now <= end_time).
      - Duplicate prevention: A student cannot mark more than once; subsequent attempts are rejected unless user is teacher with override=true.
      - Teacher override: Teachers may mark for any student_id and can override an existing record when override=true.
    """
    decorators = [firebase_auth_required]

    @blp.arguments(MarkAttendanceSchema, location="json")
    @blp.response(201, AttendanceResponseSchema)
    @blp.alt_response(400, description="Bad request")
    @blp.alt_response(403, description="Forbidden when action violates role rules")
    @blp.alt_response(404, description="Session not found")
    def post(self, json_data):
        session_id: str = json_data["session_id"]
        status: str = json_data.get("status", "present")
        reason: Optional[str] = json_data.get("reason")
        override: bool = bool(json_data.get("override", False))
        requested_student: Optional[str] = json_data.get("student_id")

        session = _SESSIONS.get(session_id)
        if not session:
            abort(404, message="Session not found")

        now = _utcnow()
        start_time: datetime = session["start_time"]
        end_time: datetime = session["end_time"]

        caller_is_teacher = "teacher" in (g.roles or [])
        target_student_id = requested_student if (caller_is_teacher and requested_student) else g.user_id

        # Enforce session window for students (teachers can override window with override flag)
        if not caller_is_teacher:
            if not (start_time <= now <= end_time):
                abort(403, message="Attendance window closed for this session")
        else:
            if not override and not (start_time <= now <= end_time):
                # Teacher without override still needs to be within the window
                abort(403, message="Attendance window closed; use override to proceed")

        # Check for existing record
        existing_idx = None
        for idx, rec in enumerate(_ATTENDANCE):
            if rec["session_id"] == session_id and rec["student_id"] == target_student_id:
                existing_idx = idx
                break

        # Duplicate prevention and override handling
        if existing_idx is not None and not (caller_is_teacher and override):
            abort(403, message="Attendance already marked for this session")

        record_id = _generate_record_id(session_id, target_student_id, len(_ATTENDANCE))
        new_record = {
            "record_id": record_id,
            "session_id": session_id,
            "student_id": target_student_id,
            "status": status,
            "reason": reason,
            "marked_at": now,
            "marked_by": g.user_id,
            "override": bool(override and caller_is_teacher),
        }

        if existing_idx is not None and caller_is_teacher and override:
            # Replace existing record
            _ATTENDANCE[existing_idx] = new_record
        else:
            _ATTENDANCE.append(new_record)

        return new_record, 201


@blp.route("/reports/daily")
class DailyReport(MethodView):
    """Get a daily report summary for a class.

    GET /reports/daily?class_id=CLASS&date=YYYY-MM-DD
    Requires Authorization: Bearer <id_token>.

    Returns per-session counts for the given date.
    """

    decorators = [firebase_auth_required]

    @blp.arguments(DailyReportQuerySchema, location="query")
    @blp.response(200, DailyReportResponseItemSchema(many=True))
    def get(self, args):
        class_id: str = args["class_id"]
        date_arg = args.get("date")
        if date_arg:
            target_date = datetime.combine(date_arg, datetime.min.time(), tzinfo=timezone.utc).date()
        else:
            target_date = _utcnow().date()

        # Filter sessions for class and date
        results = []
        for sess in _SESSIONS.values():
            if sess["class_id"] != class_id:
                continue
            sess_date = sess["start_time"].astimezone(timezone.utc).date()
            if sess_date != target_date:
                continue

            counters = {"present": 0, "absent": 0, "late": 0}
            for rec in _ATTENDANCE:
                if rec["session_id"] == sess["session_id"]:
                    counters[rec["status"]] = counters.get(rec["status"], 0) + 1
            total = sum(counters.values())

            results.append({
                "session_id": sess["session_id"],
                "class_id": sess["class_id"],
                "title": sess["title"],
                "date": target_date,
                "total_marked": total,
                "present": counters.get("present", 0),
                "absent": counters.get("absent", 0),
                "late": counters.get("late", 0),
            })

        return results, 200


@blp.route("/reports/weekly")
class WeeklyReport(MethodView):
    """Get a weekly report summary for a class.

    GET /reports/weekly?class_id=CLASS&week_start=YYYY-MM-DD
    Requires Authorization: Bearer <id_token>.

    Week runs Monday..Sunday. Defaults to current week starting Monday (UTC).
    """

    decorators = [firebase_auth_required]

    @blp.arguments(WeeklyReportQuerySchema, location="query")
    @blp.response(200, WeeklyReportResponseItemSchema(many=True))
    def get(self, args):
        class_id: str = args["class_id"]
        week_start_arg = args.get("week_start")

        today = _utcnow().date()
        if week_start_arg:
            week_start = datetime.combine(week_start_arg, datetime.min.time(), tzinfo=timezone.utc).date()
        else:
            # Monday of current week (weekday: Monday=0)
            week_start = today - timedelta(days=today.weekday())
        week_end = week_start + timedelta(days=6)

        results = []
        for sess in _SESSIONS.values():
            if sess["class_id"] != class_id:
                continue
            sess_date = sess["start_time"].astimezone(timezone.utc).date()
            if not (week_start <= sess_date <= week_end):
                continue

            counters = {"present": 0, "absent": 0, "late": 0}
            for rec in _ATTENDANCE:
                if rec["session_id"] == sess["session_id"]:
                    counters[rec["status"]] = counters.get(rec["status"], 0) + 1
            total = sum(counters.values())

            results.append({
                "session_id": sess["session_id"],
                "class_id": sess["class_id"],
                "title": sess["title"],
                "date": sess_date,
                "total_marked": total,
                "present": counters.get("present", 0),
                "absent": counters.get("absent", 0),
                "late": counters.get("late", 0),
            })

        # Sort by date then title for stable output
        results.sort(key=lambda x: (x["date"], x["title"]))
        return results, 200
